namespace Atomation.GameMap;

using Atomation.Things;
using Godot;

/// <summary>
/// collection of noise maps generated as the first step in the mao generation
/// process. these maps are passed/given to generation n steps which use them
/// in procedural generation
/// </summary>
public class GeneratedNoiseMaps
{
    /// <summary>
    /// matrix used to represent the world map's elevation
    /// </summary>
    public float[,] ElevationMap { get; set; }
    /// <summary>
    /// matrix used to represent the world map's temperature
    /// </summary>
    public float[,] TemperatureMap { get; set; }
    /// <summary>
    /// matrix used to represent the world map's moisture
    /// </summary>
    public float[,] MoistureMap { get; set; }
    /// <summary>
    /// matrix used to represent the density of trees on the game map
    /// </summary>
    public float[,] TreeDensityMap { get; set; }

    public GeneratedNoiseMaps(WorldSettings configs, Vector2I genSize, Vector2 offset)
    {
        GradientMapGenerator GradientMapGenerator = new GradientMapGenerator();
        ElevationMap = new float[genSize.X, genSize.Y];
        MoistureMap = new float[genSize.X, genSize.Y];
        TreeDensityMap = new float[genSize.X, genSize.Y];

        configs.ElevationMap.Seed=configs.MapSeed;
        configs.MoistureMap.Seed=configs.MapSeed;
        configs.TreeDensityMap.Seed=configs.MapSeed;

        for (int x = 0; x < genSize.X; x++)
        {
            for (int y = 0; y < genSize.Y; y++)
            {
                float sampleX = (x + offset.X) / configs.MapZoom;
                float sampleY = (y + offset.Y) / configs.MapZoom;

                ElevationMap[x, y] = configs.ElevationMap.GetNoise2D(sampleX, sampleY);
                MoistureMap[x, y] = configs.MoistureMap.GetNoise2D(sampleX, sampleY);
                TreeDensityMap[x, y] = configs.TreeDensityMap.GetNoise2D(sampleX, sampleY);
            }
        }
        float[,] EquatorTempMap = GradientMapGenerator.Generate(offset, genSize, configs.WorldSize, configs.TrueCenter);
        TemperatureMap = GenerationUtil.GenerateTemperatureMap(genSize, EquatorTempMap, ElevationMap, configs);
    }
}

/// <summary>
/// collection of data related to the game world generated by genSteps during 
/// the Generation process. once finished this data gets assigned to a chunk
/// to create the game world
/// </summary>
public class GeneratedMapData
{
    public Vector2I Offset { get; set; }
    public Vector2I GenSize { get; set; }

    /// <summary>
    /// matrix of contains a collection of ground/the landscape for the world generated'
    /// during the landscape generation step
    /// </summary>
    public Terrain[,] GeneratedTerrain { get; set; }

    /// <summary>
    /// matrix of contains a collection of mountains for the world generated'
    /// during the landscape generation step
    /// </summary>
    public Structure[,] GeneratedStructures { get; set; }

    /// <summary>
    /// matrix of contains a collection of plants for the world generated'
    /// during the plant generation step
    /// </summary>
    public Plant[,] GeneratedFoliage { get; set; }

    public GeneratedMapData(Vector2I chunkPosition, Vector2I genSize = default)
    {
        if (genSize == default)
        {
            genSize = new Vector2I(Chunk.CHUNK_SIZE, Chunk.CHUNK_SIZE);
        }
        this.Offset = chunkPosition;
        this.GenSize = genSize;

        GeneratedTerrain = new Terrain[genSize.X, genSize.Y];
        GeneratedStructures = new Structure[genSize.X, genSize.Y];
        GeneratedFoliage = new Plant[genSize.X, genSize.Y];
    }

    /// <summary>
    /// validates the generated data to ensure that it's all present/generated
    /// </summary>
    private bool ValidateGeneratedData()
    {

        if (GeneratedTerrain == default)
        {
            GD.PushError($"no generated terrain for current gen segment");

            return false;

        }
        if (GeneratedStructures == default)
        {
            GD.PushError($"no generated structures for current gen segment");

            return false;
        }
        if (GeneratedFoliage == default)
        {
            GD.PushError($"no foliage structures for current gen segment");

            return false;
        }
        return true;
    }

    /// <summary>
    /// uses stored data to create a new chunk
    /// </summary>
    public void GenerateChunk(ChunkHandler chunkHandler)
    {
        Chunk chunk = chunkHandler.GetChunk(Offset);

        if (chunk == null)
        {
            GD.PushError($"Chunk at {Offset} is null, can't assigned generated values");
        }

        else if (!ValidateGeneratedData())
        {
            return;
        }

        for (int x = 0; x < GenSize.X; x++)
        {
            for (int y = 0; y < GenSize.Y; y++)
            {
                chunk.SetGridObject(new Vector2(x, y), GeneratedTerrain[x, y]);
                Structure structure = GeneratedStructures[x, y];
                Plant plant = GeneratedFoliage[x,y];

                if (structure != null)
                {
                    chunk.SetGridObject(new Vector2(x, y), structure);
                }
                if (plant!=null)
                {
                    chunk.SetGridObject(new Vector2(x, y), plant);
                    
                }


            }
        }
    }
}
